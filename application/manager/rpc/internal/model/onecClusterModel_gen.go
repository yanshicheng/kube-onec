// Code generated by goctl. DO NOT EDIT.
// versions:
//  goctl version: 1.7.3

package model

import (
	"context"
	"database/sql"
	"fmt"
	"strings"
	"time"

	"github.com/zeromicro/go-zero/core/stores/builder"
	"github.com/zeromicro/go-zero/core/stores/cache"
	"github.com/zeromicro/go-zero/core/stores/sqlc"
	"github.com/zeromicro/go-zero/core/stores/sqlx"
	"github.com/zeromicro/go-zero/core/stringx"
)

var (
	onecClusterFieldNames          = builder.RawFieldNames(&OnecCluster{})
	onecClusterRows                = strings.Join(onecClusterFieldNames, ",")
	onecClusterRowsExpectAutoSet   = strings.Join(stringx.Remove(onecClusterFieldNames, "`id`", "`create_at`", "`create_time`", "`created_at`", "`update_at`", "`update_time`", "`updated_at`"), ",")
	onecClusterRowsWithPlaceHolder = strings.Join(stringx.Remove(onecClusterFieldNames, "`id`", "`create_at`", "`create_time`", "`created_at`", "`update_at`", "`update_time`", "`updated_at`"), "=?,") + "=?"

	cacheKubeOnecOnecClusterIdPrefix           = "cache:kubeOnec:onecCluster:id:"
	cacheKubeOnecOnecClusterConnTypeHostPrefix = "cache:kubeOnec:onecCluster:connType:host:"
	cacheKubeOnecOnecClusterNamePrefix         = "cache:kubeOnec:onecCluster:name:"
)

type (
	onecClusterModel interface {
		Insert(ctx context.Context, data *OnecCluster) (sql.Result, error)

		FindOne(ctx context.Context, id uint64) (*OnecCluster, error)
		Search(ctx context.Context, orderStr string, isAsc bool, page, pageSize uint64, queryStr string, args ...any) ([]*OnecCluster, uint64, error)
		SearchNoPage(ctx context.Context, orderStr string, isAsc bool, queryStr string, args ...any) ([]*OnecCluster, error)
		FindOneByConnTypeHost(ctx context.Context, connType string, host string) (*OnecCluster, error)
		FindOneByName(ctx context.Context, name string) (*OnecCluster, error)
		Update(ctx context.Context, data *OnecCluster) error
		Delete(ctx context.Context, id uint64) error
		DeleteSoft(ctx context.Context, id uint64) error
		TransCtx(ctx context.Context, fn func(context.Context, sqlx.Session) error) error
		TransOnSql(ctx context.Context, session sqlx.Session, id uint64, sqlStr string, args ...any) (sql.Result, error)
		ExecSql(ctx context.Context, id uint64, sqlStr string, args ...any) (sql.Result, error)
	}

	defaultOnecClusterModel struct {
		sqlc.CachedConn
		table string
	}

	OnecCluster struct {
		Id                uint64       `db:"id"`                  // 自增主键
		Name              string       `db:"name"`                // 集群名称
		SkipInsecure      int64        `db:"skip_insecure"`       // 是否跳过不安全连接（0：否，1：是）
		Host              string       `db:"host"`                // 集群主机地址
		Token             string       `db:"token"`               // 访问集群的令牌
		ConnType          string       `db:"conn_type"`           // 连接类型
		EnvCode           string       `db:"env_code"`            // 集群环境标签 数据字典表
		Status            int64        `db:"status"`              // 集群状态
		Version           string       `db:"version"`             // 集群版本
		Commit            string       `db:"commit"`              // 集群提交版本
		Platform          string       `db:"platform"`            // 集群平台
		VersionBuildTime  time.Time    `db:"version_build_time"`  // 版本构建时间
		ClusterCreateTime time.Time    `db:"cluster_create_time"` // 集群创建时间
		NodeCount         int64        `db:"node_count"`          // 节点数量
		TotalCpu          int64        `db:"total_cpu"`           // 总 CPU
		TotalMemory       int64        `db:"total_memory"`        // 总内存
		TotalMaxPods      int64        `db:"total_max_pods"`      // 最大 Pod 数量
		Location          string       `db:"location"`            // 集群所在地址
		IngressLbIp       string       `db:"ingress_lb_ip"`       // Ingress 负载均衡 IP
		Description       string       `db:"description"`         // 集群描述信息
		CreateBy          string       `db:"create_by"`           // 记录创建人
		UpdateBy          string       `db:"update_by"`           // 记录更新人
		CreateTime        time.Time    `db:"create_time"`         // 记录创建时间
		UpdateTime        time.Time    `db:"update_time"`         // 记录更新时间
		DeleteTime        sql.NullTime `db:"delete_time"`         // 记录删除时间（软删除）
	}
)

func newOnecClusterModel(conn sqlx.SqlConn, c cache.CacheConf, opts ...cache.Option) *defaultOnecClusterModel {
	return &defaultOnecClusterModel{
		CachedConn: sqlc.NewConn(conn, c, opts...),
		table:      "`onec_cluster`",
	}
}

func (m *defaultOnecClusterModel) Delete(ctx context.Context, id uint64) error {
	data, err := m.FindOne(ctx, id)
	if err != nil {
		return err
	}

	kubeOnecOnecClusterConnTypeHostKey := fmt.Sprintf("%s%v:%v", cacheKubeOnecOnecClusterConnTypeHostPrefix, data.ConnType, data.Host)
	kubeOnecOnecClusterIdKey := fmt.Sprintf("%s%v", cacheKubeOnecOnecClusterIdPrefix, id)
	kubeOnecOnecClusterNameKey := fmt.Sprintf("%s%v", cacheKubeOnecOnecClusterNamePrefix, data.Name)
	_, err = m.ExecCtx(ctx, func(ctx context.Context, conn sqlx.SqlConn) (result sql.Result, err error) {
		query := fmt.Sprintf("delete from %s where `id` = ?", m.table)
		return conn.ExecCtx(ctx, query, id)
	}, kubeOnecOnecClusterConnTypeHostKey, kubeOnecOnecClusterIdKey, kubeOnecOnecClusterNameKey)
	return err
}

func (m *defaultOnecClusterModel) DeleteSoft(ctx context.Context, id uint64) error {
	data, err := m.FindOne(ctx, id)
	if err != nil {
		return err
	}
	// 如果记录已软删除，无需再次删除
	if data.DeleteTime.Valid {
		return nil
	}
	kubeOnecOnecClusterConnTypeHostKey := fmt.Sprintf("%s%v:%v", cacheKubeOnecOnecClusterConnTypeHostPrefix, data.ConnType, data.Host)
	kubeOnecOnecClusterIdKey := fmt.Sprintf("%s%v", cacheKubeOnecOnecClusterIdPrefix, id)
	kubeOnecOnecClusterNameKey := fmt.Sprintf("%s%v", cacheKubeOnecOnecClusterNamePrefix, data.Name)
	_, err = m.ExecCtx(ctx, func(ctx context.Context, conn sqlx.SqlConn) (result sql.Result, err error) {
		query := fmt.Sprintf("update %s set delete_time = NOW() where `id` = ?", m.table)
		return conn.ExecCtx(ctx, query, id)
	}, kubeOnecOnecClusterConnTypeHostKey, kubeOnecOnecClusterIdKey, kubeOnecOnecClusterNameKey)
	return err
}

func (m *defaultOnecClusterModel) TransCtx(ctx context.Context, fn func(context.Context, sqlx.Session) error) error {
	return m.TransactCtx(ctx, func(ctx context.Context, session sqlx.Session) error {
		return fn(ctx, session)
	})
}

func (m *defaultOnecClusterModel) TransOnSql(ctx context.Context, session sqlx.Session, id uint64, sqlStr string, args ...any) (sql.Result, error) {
	query := strings.ReplaceAll(sqlStr, "{table}", m.table)
	// 如果 id != 0 并且启用了缓存逻辑
	if !isZeroValue(id) {
		// 查询数据（如果需要，确保数据存在）
		data, err := m.FindOne(ctx, id)
		if err != nil {
			return nil, err
		}

		// 缓存相关处理

		kubeOnecOnecClusterConnTypeHostKey := fmt.Sprintf("%s%v:%v", cacheKubeOnecOnecClusterConnTypeHostPrefix, data.ConnType, data.Host)
		kubeOnecOnecClusterIdKey := fmt.Sprintf("%s%v", cacheKubeOnecOnecClusterIdPrefix, id)
		kubeOnecOnecClusterNameKey := fmt.Sprintf("%s%v", cacheKubeOnecOnecClusterNamePrefix, data.Name) // 处理缓存逻辑，例如删除或更新缓存
		// 执行带缓存处理的 SQL 操作
		return m.ExecCtx(ctx, func(ctx context.Context, conn sqlx.SqlConn) (sql.Result, error) {
			return session.ExecCtx(ctx, query, args...)
		}, kubeOnecOnecClusterConnTypeHostKey, kubeOnecOnecClusterIdKey, kubeOnecOnecClusterNameKey) // 传递缓存相关的键值

	}

	// 如果 id == 0 或不需要缓存，直接执行 SQL
	return m.ExecCtx(ctx, func(ctx context.Context, conn sqlx.SqlConn) (sql.Result, error) {
		return session.ExecCtx(ctx, query, args...)
	})
}

func (m *defaultOnecClusterModel) ExecSql(ctx context.Context, id uint64, sqlStr string, args ...any) (sql.Result, error) {
	// 如果 id != 0 并且启用了缓存逻辑
	query := strings.ReplaceAll(sqlStr, "{table}", m.table)
	if !isZeroValue(id) {
		// 缓存相关处理

		// 查询数据（如果需要，确保数据存在）
		data, err := m.FindOne(ctx, id)
		if err != nil {
			return nil, err
		}

		kubeOnecOnecClusterConnTypeHostKey := fmt.Sprintf("%s%v:%v", cacheKubeOnecOnecClusterConnTypeHostPrefix, data.ConnType, data.Host)
		kubeOnecOnecClusterIdKey := fmt.Sprintf("%s%v", cacheKubeOnecOnecClusterIdPrefix, id)
		kubeOnecOnecClusterNameKey := fmt.Sprintf("%s%v", cacheKubeOnecOnecClusterNamePrefix, data.Name) // 处理缓存逻辑，例如删除或更新缓存
		// 执行带缓存处理的 SQL 操作
		return m.ExecCtx(ctx, func(ctx context.Context, conn sqlx.SqlConn) (sql.Result, error) {
			return conn.ExecCtx(ctx, query, args...)
		}, kubeOnecOnecClusterConnTypeHostKey, kubeOnecOnecClusterIdKey, kubeOnecOnecClusterNameKey) // 传递缓存相关的键值

	}

	// 如果 id == 0 或不需要缓存，直接执行 SQL
	return m.ExecCtx(ctx, func(ctx context.Context, conn sqlx.SqlConn) (sql.Result, error) {
		return conn.ExecCtx(ctx, query, args...)
	})
}
func (m *defaultOnecClusterModel) FindOne(ctx context.Context, id uint64) (*OnecCluster, error) {
	kubeOnecOnecClusterIdKey := fmt.Sprintf("%s%v", cacheKubeOnecOnecClusterIdPrefix, id)
	var resp OnecCluster
	err := m.QueryRowCtx(ctx, &resp, kubeOnecOnecClusterIdKey, func(ctx context.Context, conn sqlx.SqlConn, v any) error {
		query := fmt.Sprintf("select %s from %s where `id` = ? AND `delete_time` IS NULL limit 1", onecClusterRows, m.table)
		return conn.QueryRowCtx(ctx, v, query, id)
	})
	switch err {
	case nil:
		return &resp, nil
	case sqlc.ErrNotFound:
		return nil, ErrNotFound
	default:
		return nil, err
	}
}

func (m *defaultOnecClusterModel) Search(ctx context.Context, orderStr string, isAsc bool, page, pageSize uint64, queryStr string, args ...any) ([]*OnecCluster, uint64, error) {
	// 确保分页参数有效
	if page < 1 {
		page = 1
	}
	if pageSize < 1 {
		pageSize = 20
	}

	// 构造查询条件
	// 添加 delete_time IS NULL 条件，保证只查询未软删除数据
	// 初始化 WHERE 子句
	where := "WHERE delete_time IS NULL"
	if queryStr != "" {
		where = fmt.Sprintf("WHERE %s AND delete_time IS NULL", queryStr)
	}

	// 根据 isAsc 参数确定排序方式
	sortDirection := "ASC"
	if !isAsc {
		sortDirection = "DESC"
	}

	// 如果用户未指定排序字段，则默认使用 id
	if orderStr == "" {
		orderStr = fmt.Sprintf("ORDER BY id %s", sortDirection)
	} else {
		orderStr = strings.TrimSpace(orderStr)
		if !strings.HasPrefix(strings.ToUpper(orderStr), "ORDER BY") {
			orderStr = "ORDER BY " + orderStr
		}
		orderStr = fmt.Sprintf("%s %s", orderStr, sortDirection)
	}

	countQuery := fmt.Sprintf("SELECT COUNT(1) FROM %s %s", m.table, where)

	var total uint64
	var resp []*OnecCluster
	err := m.QueryRowNoCacheCtx(ctx, &total, countQuery, args...)
	if err != nil {
		return nil, 0, err
	}
	if total == 0 {
		// 无匹配记录
		return resp, 0, ErrNotFound
	}
	offset := (page - 1) * pageSize
	dataQuery := fmt.Sprintf("SELECT %s FROM %s %s %s LIMIT %d,%d", onecClusterRows, m.table, where, orderStr, offset, pageSize)

	err = m.QueryRowsNoCacheCtx(ctx, &resp, dataQuery, args...)
	if err != nil {
		return nil, 0, err
	}

	return resp, total, nil
}

func (m *defaultOnecClusterModel) SearchNoPage(ctx context.Context, orderStr string, isAsc bool, queryStr string, args ...any) ([]*OnecCluster, error) {
	// 初始化 WHERE 子句
	where := "WHERE delete_time IS NULL"
	if queryStr != "" {
		where = fmt.Sprintf("WHERE %s AND delete_time IS NULL", queryStr)
	}

	// 根据 isAsc 参数确定排序方式
	sortDirection := "ASC"
	if !isAsc {
		sortDirection = "DESC"
	}
	// 如果用户未指定排序字段，则默认使用 id
	if orderStr == "" {
		orderStr = fmt.Sprintf("ORDER BY id %s", sortDirection)
	} else {
		orderStr = strings.TrimSpace(orderStr)
		if !strings.HasPrefix(strings.ToUpper(orderStr), "ORDER BY") {
			orderStr = "ORDER BY " + orderStr
		}
		orderStr = fmt.Sprintf("%s %s", orderStr, sortDirection)
	}
	dataQuery := fmt.Sprintf("SELECT %s FROM %s %s %s", onecClusterRows, m.table, where, orderStr)
	var resp []*OnecCluster
	err := m.QueryRowsNoCacheCtx(ctx, &resp, dataQuery, args...)
	switch err {
	case nil:
		return resp, nil
	case sqlx.ErrNotFound:
		return nil, ErrNotFound
	default:
		return nil, err
	}
}
func (m *defaultOnecClusterModel) FindOneByConnTypeHost(ctx context.Context, connType string, host string) (*OnecCluster, error) {
	kubeOnecOnecClusterConnTypeHostKey := fmt.Sprintf("%s%v:%v", cacheKubeOnecOnecClusterConnTypeHostPrefix, connType, host)
	var resp OnecCluster
	err := m.QueryRowIndexCtx(ctx, &resp, kubeOnecOnecClusterConnTypeHostKey, m.formatPrimary, func(ctx context.Context, conn sqlx.SqlConn, v any) (i any, e error) {
		query := fmt.Sprintf("select %s from %s where `conn_type` = ? and `host` = ? AND `delete_time` IS NULL limit 1", onecClusterRows, m.table)
		if err := conn.QueryRowCtx(ctx, &resp, query, connType, host); err != nil {
			return nil, err
		}
		return resp.Id, nil
	}, m.queryPrimary)
	switch err {
	case nil:
		return &resp, nil
	case sqlc.ErrNotFound:
		return nil, ErrNotFound
	default:
		return nil, err
	}
}

func (m *defaultOnecClusterModel) FindOneByName(ctx context.Context, name string) (*OnecCluster, error) {
	kubeOnecOnecClusterNameKey := fmt.Sprintf("%s%v", cacheKubeOnecOnecClusterNamePrefix, name)
	var resp OnecCluster
	err := m.QueryRowIndexCtx(ctx, &resp, kubeOnecOnecClusterNameKey, m.formatPrimary, func(ctx context.Context, conn sqlx.SqlConn, v any) (i any, e error) {
		query := fmt.Sprintf("select %s from %s where `name` = ? AND `delete_time` IS NULL limit 1", onecClusterRows, m.table)
		if err := conn.QueryRowCtx(ctx, &resp, query, name); err != nil {
			return nil, err
		}
		return resp.Id, nil
	}, m.queryPrimary)
	switch err {
	case nil:
		return &resp, nil
	case sqlc.ErrNotFound:
		return nil, ErrNotFound
	default:
		return nil, err
	}
}

func (m *defaultOnecClusterModel) Insert(ctx context.Context, data *OnecCluster) (sql.Result, error) {
	kubeOnecOnecClusterConnTypeHostKey := fmt.Sprintf("%s%v:%v", cacheKubeOnecOnecClusterConnTypeHostPrefix, data.ConnType, data.Host)
	kubeOnecOnecClusterIdKey := fmt.Sprintf("%s%v", cacheKubeOnecOnecClusterIdPrefix, data.Id)
	kubeOnecOnecClusterNameKey := fmt.Sprintf("%s%v", cacheKubeOnecOnecClusterNamePrefix, data.Name)
	ret, err := m.ExecCtx(ctx, func(ctx context.Context, conn sqlx.SqlConn) (result sql.Result, err error) {
		query := fmt.Sprintf("insert into %s (%s) values (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)", m.table, onecClusterRowsExpectAutoSet)
		return conn.ExecCtx(ctx, query, data.Name, data.SkipInsecure, data.Host, data.Token, data.ConnType, data.EnvCode, data.Status, data.Version, data.Commit, data.Platform, data.VersionBuildTime, data.ClusterCreateTime, data.NodeCount, data.TotalCpu, data.TotalMemory, data.TotalMaxPods, data.Location, data.IngressLbIp, data.Description, data.CreateBy, data.UpdateBy, data.DeleteTime)
	}, kubeOnecOnecClusterConnTypeHostKey, kubeOnecOnecClusterIdKey, kubeOnecOnecClusterNameKey)
	return ret, err
}

func (m *defaultOnecClusterModel) Update(ctx context.Context, newData *OnecCluster) error {
	data, err := m.FindOne(ctx, newData.Id)
	if err != nil {
		return err
	}

	kubeOnecOnecClusterConnTypeHostKey := fmt.Sprintf("%s%v:%v", cacheKubeOnecOnecClusterConnTypeHostPrefix, data.ConnType, data.Host)
	kubeOnecOnecClusterIdKey := fmt.Sprintf("%s%v", cacheKubeOnecOnecClusterIdPrefix, data.Id)
	kubeOnecOnecClusterNameKey := fmt.Sprintf("%s%v", cacheKubeOnecOnecClusterNamePrefix, data.Name)
	_, err = m.ExecCtx(ctx, func(ctx context.Context, conn sqlx.SqlConn) (result sql.Result, err error) {
		query := fmt.Sprintf("update %s set %s where `id` = ?", m.table, onecClusterRowsWithPlaceHolder)
		return conn.ExecCtx(ctx, query, newData.Name, newData.SkipInsecure, newData.Host, newData.Token, newData.ConnType, newData.EnvCode, newData.Status, newData.Version, newData.Commit, newData.Platform, newData.VersionBuildTime, newData.ClusterCreateTime, newData.NodeCount, newData.TotalCpu, newData.TotalMemory, newData.TotalMaxPods, newData.Location, newData.IngressLbIp, newData.Description, newData.CreateBy, newData.UpdateBy, newData.DeleteTime, newData.Id)
	}, kubeOnecOnecClusterConnTypeHostKey, kubeOnecOnecClusterIdKey, kubeOnecOnecClusterNameKey)
	return err
}

func (m *defaultOnecClusterModel) formatPrimary(primary any) string {
	return fmt.Sprintf("%s%v", cacheKubeOnecOnecClusterIdPrefix, primary)
}

func (m *defaultOnecClusterModel) queryPrimary(ctx context.Context, conn sqlx.SqlConn, v, primary any) error {
	query := fmt.Sprintf("select %s from %s where `id` = ? AND `delete_time` IS NULL limit 1", onecClusterRows, m.table)
	return conn.QueryRowCtx(ctx, v, query, primary)
}

func (m *defaultOnecClusterModel) tableName() string {
	return m.table
}
