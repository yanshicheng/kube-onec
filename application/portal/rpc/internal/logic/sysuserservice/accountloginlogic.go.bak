package sysuserservicelogic

import (
	"context"
	"fmt"
	"github.com/yanshicheng/kube-onec/application/portal/rpc/internal/code"
	"github.com/yanshicheng/kube-onec/application/portal/rpc/internal/model"
	"github.com/yanshicheng/kube-onec/common/handler/errorx"
	"github.com/yanshicheng/kube-onec/pkg/jwt"
	"github.com/yanshicheng/kube-onec/utils"
	"time"

	"github.com/yanshicheng/kube-onec/application/portal/rpc/internal/svc"
	"github.com/yanshicheng/kube-onec/application/portal/rpc/pb"

	"github.com/zeromicro/go-zero/core/logx"
)

type AccountLoginLogic struct {
	ctx    context.Context
	svcCtx *svc.ServiceContext
	logx.Logger
}

func NewAccountLoginLogic(ctx context.Context, svcCtx *svc.ServiceContext) *AccountLoginLogic {
	return &AccountLoginLogic{
		ctx:    ctx,
		svcCtx: svcCtx,
		Logger: logx.WithContext(ctx),
	}
}
func (l *AccountLoginLogic) AccountLogin(in *pb.LoginReq) (*pb.LoginResp, error) {
	// 查询账号
	user, err := l.svcCtx.SysUser.FindOneByAccount(l.ctx, in.Account)
	if err != nil {
		l.Logger.Errorf("查询账号失败, 账号: %s, 错误: %v", in.Account, err)
		return nil, code.FindAccountErr
	}
	// 验证是否需要重置密码
	if user.IsResetPassword == 1 {
		l.Logger.Infof("账号需要重置密码, 账号: %s", in.Account)
		return nil, code.ResetPasswordTip
	}
	// 检查账号是否被冻结
	if user.IsDisabled == 1 {
		l.Logger.Infof("账号已被冻结, 账号: %s", in.Account)
		return nil, code.FrozenAccountsErr
	}

	// 处理密码验证逻辑
	if err := l.verifyPassword(in.Password, user.Password); err != nil {
		// 如果密码验证失败，记录登录失败次数
		if err := l.recordLoginFailure(user); err != nil {
			l.Logger.Errorf("记录登录失败次数时发生错误, 账号: %s, 错误: %v", in.Account, err)
			return nil, code.ChangePasswordErr
		}
		return nil, code.LoginErr
	}

	// 查询所有角色信息
	sqlStr := "user_id = ?"
	roles, err := l.svcCtx.SysUserRole.SearchNoPage(l.ctx, "id", false, sqlStr, user.Id)
	var rolesNames []string
	var rolesIds []uint64

	if err != nil {
		// 查询过程中的其他错误
		l.Logger.Errorf("查询角色信息失败，用户=%d，错误信息：%v", user.Id, err)
		return nil, errorx.ServerDataQueryErr
	}

	if len(roles) == 0 {
		rolesNames = append(rolesNames, "user")
	}
	for _, userRole := range roles {
		role, err := l.svcCtx.SysRole.FindOne(l.ctx, userRole.RoleId)
		if err != nil {
			continue
		}
		rolesNames = append(rolesNames, role.RoleCode)
		rolesIds = append(rolesIds, role.Id)
	}
	l.Logger.Infof("账号登录成功, 账号: %s", in.Account)
	uuid, err := utils.GenerateRandomID()
	if err != nil {
		l.Logger.Errorf("生成UUID失败, 错误: %v", err)
		return nil, code.GenerateUUIDErr
	}
	accessToken, err := jwt.BuildTokens(jwt.TokenOptions{
		AccessSecret: l.svcCtx.Config.AuthConfig.AccessSecret,
		AccessExpire: l.svcCtx.Config.AuthConfig.AccessExpire,
		Fields: map[string]interface{}{
			"accountId":   user.Id,
			"account":     user.Account,
			"roles":       rolesNames,
			"accountUUID": uuid,
		},
	})

	refreshToken, err := jwt.BuildTokens(jwt.TokenOptions{
		AccessSecret: l.svcCtx.Config.AuthConfig.RefreshSecret,
		AccessExpire: l.svcCtx.Config.AuthConfig.RefreshExpire,
		Fields: map[string]interface{}{
			"account": user.Account,
		},
	})
	// 登录成功，返回响应
	return &pb.LoginResp{
		AccountId: user.Id,
		Account:   user.Account,
		UserName:  user.UserName,
		Roles:     rolesNames,
		Token: &pb.Token{
			AccessToken:      accessToken.AccessToken,
			AccessExpiresIn:  accessToken.AccessExpire,
			RefreshToken:     refreshToken.AccessToken,
			RefreshExpiresIn: refreshToken.AccessExpire,
		},
	}, nil
}

// 验证密码是否正确
func (l *AccountLoginLogic) verifyPassword(inputPassword, hashedPassword string) error {
	// 解码密码
	password, err := utils.DecodeBase64Password(inputPassword)
	if err != nil {
		l.Logger.Errorf("密码解码失败: %v", err)
		return code.DecodeBase64PasswordErr
	}

	// 校验密码
	if !utils.CheckPasswordHash(password, hashedPassword) {
		l.Logger.Infof("密码验证失败")
		return code.LoginErr
	}

	return nil
}

// 记录登录失败次数，如果 5 分钟内连续失败 3 次则禁用账号
func (l *AccountLoginLogic) recordLoginFailure(user *model.SysUser) error {
	// Redis 键，存储账号的登录失败次数
	loginFailKey := fmt.Sprintf("login_fail_%s", user.Account)

	// 设置失败记录的过期时间为 5 分钟
	const maxFailCount = 3
	const lockDuration = 5 * time.Minute

	// 递增登录失败次数，同时检查当前次数
	failCount, err := l.svcCtx.Cache.Incr(loginFailKey)
	if err != nil {
		return fmt.Errorf("Redis Incr 操作失败: %w", err)
	}

	// 如果这是第一次失败，设置失败次数的过期时间为 5 分钟
	if failCount == 1 {
		if err := l.svcCtx.Cache.Expire(loginFailKey, int(lockDuration.Seconds())); err != nil {
			return fmt.Errorf("Redis 设置过期时间失败: %w", err)
		}
	}

	// 检查是否达到最大失败次数
	if failCount >= maxFailCount {
		// 禁用账号的业务逻辑（可以通过数据库标记账号为禁用）
		if err := l.disableAccount(user); err != nil {
			return fmt.Errorf("禁用账号失败: %w", err)
		}
		// 删除 Redis 中的失败记录，避免重复触发
		if _, err := l.svcCtx.Cache.Del(loginFailKey); err != nil {
			return fmt.Errorf("删除 Redis 登录失败记录失败: %w", err)
		}

		l.Logger.Infof("账号已被禁用, 账号: %s", user.Account)
		return code.AccountLockedErr
	}

	l.Logger.Infof("登录失败计数: %d, 账号: %s", failCount, user.Account)
	return nil
}

// 禁用账号（可以根据具体业务实现，例如更新数据库状态）
func (l *AccountLoginLogic) disableAccount(user *model.SysUser) error {
	// 示例实现：将账号设置为禁用状态
	user.IsDisabled = 1
	err := l.svcCtx.SysUser.Update(l.ctx, user)
	if err != nil {
		l.Logger.Errorf("禁用账号失败, 账号: %s, 错误: %v", user.Account, err)
		return err
	}
	return nil
}
